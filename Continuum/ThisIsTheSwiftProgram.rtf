{\rtf1\ansi\ansicpg1252\cocoartf2513
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Menlo-Bold;\f1\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red252\green95\blue163;\red31\green31\blue36;\red255\green255\blue255;
\red65\green161\blue192;\red208\green168\blue255;\red208\green191\blue105;}
{\*\expandedcolortbl;;\csgenericrgb\c98839\c37355\c63833;\csgenericrgb\c12054\c12284\c14131;\csgenericrgb\c100000\c100000\c100000\c85000;
\csgenericrgb\c25490\c63137\c75294;\csgenericrgb\c81569\c65882\c100000;\csgenericrgb\c81498\c74939\c41233;}
\margl1440\margr1440\vieww17720\viewh20980\viewkind0
\deftab593
\pard\tx593\pardeftab593\pardirnatural\partightenfactor0

\f0\b\fs24 \cf2 \cb3 //This program doesn\'92t include anything that requires Xcode to run\'85I think.\
\
\
func
\f1\b0 \cf4  \cf5 getCptFactor\cf4 (base: \cf6 Double\cf4 , digits: \cf6 Double\cf4 ) -> \cf6 Double\cf4  \{ //-> Double means it returns a double\
    
\f0\b \cf2 let
\f1\b0 \cf4  new_seconds = pow(base, digits) //let is used for constants, var for normal variables\
    
\f0\b \cf2 let
\f1\b0 \cf4  cpt_factor = new_seconds / \cf7 86400.0 //The .0 is important cause Swift is picky about types\cf4 \
    
\f0\b \cf2 return
\f1\b0 \cf4  cpt_factor\
\}\
\
//I had to make a function for each side of the decimal due to formatting challenges\

\f0\b \cf2 func
\f1\b0 \cf4  \cf5 getDoubleLeftSide\cf4 () -> \cf6 Double\cf4  \{\
    
\f0\b \cf2 let
\f1\b0 \cf4  date = Date() //Comes from thin air. I don\'92t know if you\'92ll be able to import Date() or something\
    
\f0\b \cf2 let
\f1\b0 \cf4  calendar = Calendar.current\
    
\f0\b \cf2 let
\f1\b0 \cf4  hour = calendar.component(.hour, from: date)\
    
\f0\b \cf2 let
\f1\b0 \cf4  minutes = calendar.component(.minute, from: date)\
    
\f0\b \cf2 let
\f1\b0 \cf4  seconds = calendar.component(.second, from: date)\
    
\f0\b \cf2 let
\f1\b0 \cf4  total_seconds:\cf6 Double\cf4  = Double(seconds + minutes * \cf7 60\cf4  + hour * \cf7 3600\cf4 )\
    
\f0\b \cf2 return
\f1\b0 \cf4  total_seconds\
\}\
\

\f0\b \cf2 func
\f1\b0 \cf4  \cf5 getDoubleRightSide\cf4 () -> \cf6 Double\cf4  \{\
    
\f0\b \cf2 let
\f1\b0 \cf4  formatter = NumberFormatter() //To the best of my knowledge, NumberFormatter also comes out of thin air\
    formatter.minimumFractionDigits = \cf7 6\cf4 \
    formatter.maximumIntegerDigits = \cf7 0\cf4 \
    
\f0\b \cf2 let
\f1\b0 \cf4  time_string_double = formatter.string(for: Date().timeIntervalSince1970) //magically gets time(i think down to nanos) since Jan 1, 1970\
    
\f0\b \cf2 let
\f1\b0 \cf4  right_side = (time_string_double! 
\f0\b \cf2 as
\f1\b0 \cf4  \cf6 NSString\cf4 ).doubleValue\
    
\f0\b \cf2 return
\f1\b0 \cf4  right_side\
\}\
\
//This function gets the full decimal time(I call standard time Mixed Positional Time, so this is normal seconds+millis-nanos?) I think I also call standard time tripartite positional time and other things.\

\f0\b \cf2 func
\f1\b0 \cf4  \cf5 getDoubleMPT\cf4 (left_side:\cf6 Double\cf4 , right_side:\cf6 Double\cf4 ) -> \cf6 Double\cf4  \{\
    
\f0\b \cf2 let
\f1\b0 \cf4  time_mpt:\cf6 Double\cf4  = left_side + right_side\
    
\f0\b \cf2 return
\f1\b0 \cf4  time_mpt\
\}\
\
//Give this function your desired base and number of digits and it will call the other functions and return the appropriate string for time in CPT(Continuous Positional Time).\

\f0\b \cf2 func
\f1\b0 \cf4  \cf5 getCptTime\cf4 (base:\cf6 Double\cf4 , digits:\cf6 Double\cf4 ) -> \cf6 String\cf4  \{\
    
\f0\b \cf2 let
\f1\b0 \cf4  cpt_factor = getCptFactor(base: base, digits: digits)\
    
\f0\b \cf2 let
\f1\b0 \cf4  cpt_time_decimal = getDoubleMPT(left_side: getDoubleLeftSide(), right_side: getDoubleRightSide()) * cpt_factor\
    
\f0\b \cf2 return
\f1\b0 \cf4  String(Int(floor(cpt_time_decimal)), radix: Int(base)) //Lots of casting and converting. Luckily, casting a number to a string provides the built in ability to change bases. Hence radix: Int(base)\
\}\
\
\
print(getCptTime(base: 16.0, digits: 4.0))}